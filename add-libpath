#!/usr/bin/env bash
# Adds a library directory to PATH in .bashrc

# Environment setup
set -o pipefail
SCRIPT_DIR="$(cd "${BASH_SOURCE[0]%/*}" || exit 1; pwd)"
export PATH="${PATH}:${SCRIPT_DIR}"
source "${SCRIPT_DIR}/bash_modules/terminal.sh"

function print_usage() {
  cat <<EOF
Usage: $(basename "$0") [lib_name]

Adds a library directory to PATH in .bashrc if not already present.

Dependencies:
  fzf                For interactive directory selection
  lsd                For directory listing in preview
  rg                 For searching .bashrc file
  fd                 For finding directories

Required arguments:
  lib_name           Name or part of library directory name (optional)

Optional arguments:
  -h, --help         Show this help message and exit
EOF
}

if [[ $# -gt 1 || "${1}" == "-h" || "${1}" == "--help" ]]; then
  print_usage
  exit 1
fi

log_title "Add Library Path"

lib_dir="${SCRIPT_DIR}/lib"
lib_name="${1}"

if [[ ! -d "${lib_dir}" ]]; then
  log_error "ERROR: Library directory '${lib_dir}' does not exist"
  exit 1
fi

# Dependency check
dependencies=(fzf lsd rg fd)
for cmd in "${dependencies[@]}"; do
  if ! command -v "${cmd}" >/dev/null; then
    log_error "ERROR: Missing dependency - '${cmd}'"
    exit 1
  fi
done

mapfile -t lib_dirs < <(fd -t d -d 1 . "${lib_dir}")
if [[ ${#lib_dirs[@]} -eq 0 ]]; then
  log_error "ERROR: No library directories found in '${lib_dir}'"
  exit 1
fi

# Extract just the directory names for display
mapfile -t lib_names < <(printf "%s\n" "${lib_dirs[@]}" | xargs -I {} basename {})

selected_dir=""
if [[ -n "${lib_name}" ]]; then
  mapfile -t matches < <(fd -t d -d 1 "${lib_name}" "${lib_dir}")
  if [[ ${#matches[@]} -eq 1 ]]; then
    selected_dir="${matches[0]}"
  elif [[ ${#matches[@]} -gt 1 ]]; then
    mapfile -t match_names < <(printf "%s\n" "${matches[@]}" | xargs -I {} basename {})
    selected_name=$(printf "%s\n" "${match_names[@]}" | fzf --prompt="Select library directory: " --query="${lib_name}" --preview "lsd --oneline --group-directories-first '${lib_dir}/{}'")
    [[ -z "${selected_name}" ]] && { log_error "ERROR: No directory selected"; exit 1; }
    selected_dir="${lib_dir}/${selected_name}"
  else
    log_warning "No exact match for '${lib_name}', using fzf to select"
    selected_name=$(printf "%s\n" "${lib_names[@]}" | fzf --prompt="Select library directory: " --query="${lib_name}" --preview "lsd --oneline --group-directories-first '${lib_dir}/{}'")
    [[ -z "${selected_name}" ]] && { log_error "ERROR: No directory selected"; exit 1; }
    selected_dir="${lib_dir}/${selected_name}"
  fi
else
  selected_name=$(printf "%s\n" "${lib_names[@]}" | fzf --prompt="Select library directory: " --preview "lsd --oneline --group-directories-first '${lib_dir}/{}'")
  [[ -z "${selected_name}" ]] && { log_error "ERROR: No directory selected"; exit 1; }
  selected_dir="${lib_dir}/${selected_name}"
fi

log_message "Library: ${selected_dir}"
log_message "Checking .bashrc..."
bashrc="${HOME}/.bashrc"
lib_path_pattern="/lib/$(basename "${selected_dir}")"
if rg -F "${lib_path_pattern}" "${bashrc}" >/dev/null; then
  log_success "Path containing '${lib_path_pattern}' already in .bashrc"
  exit 0
fi

# Convert absolute path to use ${HOME} variable
# Remove any trailing slash from selected_dir
selected_dir="${selected_dir%/}"
relative_path="${selected_dir/#${HOME}/\${HOME\}}"
echo "export PATH=\"\${PATH}:${relative_path}\"" >> "${bashrc}"
log_success "Added '${relative_path}' to PATH in .bashrc"
