#!/usr/bin/env bash

# Environment setup
# -----------------------------------------------------------------------------
set -o pipefail
[[ ${DEBUG-} ]] && set -o xtrace
SCRIPT_DIR="$(cd "${BASH_SOURCE[0]%/*}" || exit 1; pwd)"
[[ ":${PATH}:" != *:"${SCRIPT_DIR}":* ]] && export PATH="${SCRIPT_DIR}:${PATH}"
source "${SCRIPT_DIR}/bash_modules/terminal.sh"
[[ -z ${BASH_MODULES_DIR-} ]] && echo "ERROR: terminal.sh module missing" && exit 1

function print_usage() {
  cat <<EOF
Usage: $(basename "$0") <url> [options]
       $(basename "$0") --open-browser [options]

Seamlessly fetches webpage content and converts to Markdown using intelligent Chromium automation

Required arguments:
  url                    The URL to fetch (auto-detects protocol if omitted)

Optional arguments:
  -t, --timeout <seconds>    Page load timeout in seconds (default: 30)
  -o, --output <file>        Save output to file instead of stdout
  -w, --wait-for <selector>  Wait for CSS selector before extracting content
  -c, --close-tab            Close the browser tab after fetching content
  --html                     Return raw HTML instead of Markdown (default: false)
  --debug                    Enable debug output
  -p, --port <port>          Chrome remote debugging port (default: 9222)
  -fh, --force-headless      Force headless mode even if Chromium is running
  -fv, --force-visible       Force visible mode for authentication
  -ob, --open-browser        Open Chromium browser in visible state for authentication
  -h, --help                 Show this help message and exit

Dependencies:
  - node (Node.js runtime)
  - html2markdown (brew install JohannesKaufmann/tap/html2markdown)

Workflow:
- If Chromium is running: Uses existing session (preserves authentication)
- If Chromium not running: Launches headless mode for quick fetching
- If authentication required: Automatically launches visible Chromium
- Tab management: Keeps tabs open in visible/connect mode unless --close-tab used
- Converts HTML to clean Markdown by default

Examples:
  $(basename "$0") example.com
  $(basename "$0") https://example.com -o page.md
  $(basename "$0") app.example.com/docs -w ".content-loaded"
  $(basename "$0") private.example.com -fv
  $(basename "$0") localhost:3000 --html
  $(basename "$0") 192.168.1.100:8080 -t 60 -c
  $(basename "$0") -ob
  $(basename "$0") -ob -p 9223
EOF
}

# Parse arguments
# -----------------------------------------------------------------------------
declare url=""
declare timeout="30"
declare output_file=""
declare wait_for_selector=""
declare debug_mode=""
declare chrome_debug_port="9222"
declare force_mode=""
declare html_output=""
declare open_browser_mode=""
declare close_tab=""

# Check for help first
if [[ $# -eq 0 || "${1}" == "-h" || "${1}" == "--help" ]]; then
  print_usage
  exit 1
fi

# Check for open browser mode first
if [[ "${1}" == "--open-browser" || "${1}" == "-ob" ]]; then
  open_browser_mode="true"
  shift
else
  # First argument should be URL (unless it starts with --)
  if [[ "${1}" =~ ^-- ]]; then
    log_error "Missing URL argument"
    log_error "URL must be the first argument"
    print_usage
    exit 1
  fi

  url="${1}"
  shift
fi

while [[ $# -gt 0 ]]; do
  case $1 in
    -t|--timeout)
      timeout="$2"
      shift 2
      ;;
    -o|--output)
      output_file="$2"
      shift 2
      ;;
    -w|--wait-for)
      wait_for_selector="$2"
      shift 2
      ;;
    -c|--close-tab)
      close_tab="true"
      shift
      ;;
    --html)
      html_output="true"
      shift
      ;;
    --debug)
      debug_mode="true"
      shift
      ;;
    -p|--port)
      chrome_debug_port="$2"
      shift 2
      ;;
    -fh|--force-headless)
      force_mode="headless"
      shift
      ;;
    -fv|--force-visible)
      force_mode="visible"
      shift
      ;;
    -ob|--open-browser)
      open_browser_mode="true"
      shift
      ;;
    *)
      log_error "Unknown option: $1"
      print_usage
      exit 1
      ;;
  esac
done

# Handle Open Browser Mode
# -----------------------------------------------------------------------------
if [[ "${open_browser_mode}" == "true" ]]; then
  [[ ${DEBUG-} ]] && log_title "Chromium Browser Startup"

  # Build chromium startup command
  chromium_cmd=("${SCRIPT_DIR}/lib/chromium/start-chromiumdebug")
  chromium_cmd+=("--port" "${chrome_debug_port}")

  if [[ "${debug_mode}" == "true" ]]; then
    [[ ${DEBUG-} ]] && log_message "Starting Chromium with command: ${chromium_cmd[*]}"
  fi

  # Execute the chromium startup script in background
  "${chromium_cmd[@]}" >/dev/null 2>&1 &

  # Give it a moment to start
  sleep 2

  # Check if it started successfully
  if pgrep -f "Chromium" >/dev/null; then
    log_success "Chromium browser started successfully on port ${chrome_debug_port}"
    log_message "Browser is ready for get-webpage commands"
  else
    log_error "Failed to start Chromium browser"
    exit 1
  fi

  exit 0
fi

# Title and Dependency Checks
# -----------------------------------------------------------------------------
[[ ${DEBUG-} ]] && log_title "Seamless Webpage Fetcher"

# Check for required tools
dependencies=(node)
if [[ "${html_output}" != "true" ]]; then
  dependencies+=(html2markdown)
fi

for cmd in "${dependencies[@]}"; do
  if ! command -v "${cmd}" >/dev/null; then
    log_error "Missing dependency - '${cmd}'"
    if [[ "${cmd}" == "html2markdown" ]]; then
      log_error "Install with: brew install JohannesKaufmann/tap/html2markdown"
      log_error "Or use --html flag to get raw HTML output"
    fi
    exit 1
  fi
done

# Check if Node.js environment is set up
if [[ ! -f "${SCRIPT_DIR}/lib/chromium/fetch-html.js" ]]; then
  log_error "Puppeteer helper script not found"
  log_error "Expected: ${SCRIPT_DIR}/lib/chromium/fetch-html.js"
  exit 1
fi

if [[ ! -d "${SCRIPT_DIR}/lib/chromium/node_modules" ]]; then
  [[ ${DEBUG-} ]] && log_message "Node.js dependencies not found, installing..."
  if cd "${SCRIPT_DIR}/lib/chromium" && npm install --silent >/dev/null 2>&1; then
    [[ ${DEBUG-} ]] && log_success "Node.js dependencies installed successfully"
  else
    log_error "Failed to install Node.js dependencies"
    log_error "Run manually: cd ${SCRIPT_DIR}/lib/chromium && npm install"
    exit 1
  fi
fi

# URL Normalization and Validation
# -----------------------------------------------------------------------------

[[ ${DEBUG-} ]] && log_heading "URL Validation"

function normalize_url() {
  local input_url="$1"

  # If already has protocol, use as-is
  if [[ "${input_url}" =~ ^https?:// ]]; then
    echo "${input_url}"
    return 0
  fi

  # If it looks like a domain name or path, add https://
  if [[ "${input_url}" =~ ^[a-zA-Z0-9.-]+(\.[a-zA-Z]{2,})?(/.*)?$ ]]; then
    echo "https://${input_url}"
    return 0
  fi

  # If it starts with localhost or an IP, add http://
  if [[ "${input_url}" =~ ^(localhost|[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}) ]]; then
    echo "http://${input_url}"
    return 0
  fi

  # Otherwise, assume https://
  echo "https://${input_url}"
}

# Normalize the URL
original_url="${url}"
url=$(normalize_url "${url}")

if [[ "${url}" != "${original_url}" ]]; then
  [[ ${DEBUG-} ]] && log_message "Normalized URL: '${original_url}' â†’ '${url}'"
fi

# Validate final URL format
if [[ ! "${url}" =~ ^https?://[^[:space:]]+$ ]]; then
  log_error "Invalid URL format: '${url}'"
  log_error "URL must be a valid web address"
  exit 1
fi

# Validate timeout is a number
if ! [[ "${timeout}" =~ ^[0-9]+$ ]]; then
  log_error "Timeout must be a positive integer"
  exit 1
fi

[[ ${DEBUG-} ]] && log_success "URL validation passed"

# Determine Operation Mode
# -----------------------------------------------------------------------------
[[ ${DEBUG-} ]] && log_heading "Determining Operation Mode"

function is_chromium_running() {
  if command -v curlie >/dev/null; then
    curlie -s "http://localhost:${chrome_debug_port}/json/version" >/dev/null 2>&1
  else
    curl -s "http://localhost:${chrome_debug_port}/json/version" >/dev/null 2>&1
  fi
}

# Determine the best mode to use
if [[ -n "${force_mode}" ]]; then
  operation_mode="${force_mode}"
  [[ ${DEBUG-} ]] && log_message "Using forced mode: '${operation_mode}'"
elif is_chromium_running; then
  operation_mode="connect"
  [[ ${DEBUG-} ]] && log_message "Chromium detected on port ${chrome_debug_port}, using existing session"
else
  operation_mode="headless"
  [[ ${DEBUG-} ]] && log_message "No Chromium detected, will launch headless mode"
fi

# Report Operational Values
# -----------------------------------------------------------------------------
[[ ${DEBUG-} ]] && log_heading "Operational Values"
[[ ${DEBUG-} ]] && log_message "$(
  cat <<EOF
           URL: '${url}'
       Timeout: '${timeout}' seconds
   Output file: '${output_file:-stdout}'
      Wait for: '${wait_for_selector:-none}'
   Output format: '$(if [[ "${html_output}" == "true" ]]; then echo "HTML"; else echo "Markdown"; fi)'
    Debug mode: '${debug_mode:-false}'
    Close tab: '${close_tab:-false}'
  Chrome port: '${chrome_debug_port}'
Operation mode: '${operation_mode}'
EOF
)"

# Execute Fetch Operation
# -----------------------------------------------------------------------------
[[ ${DEBUG-} ]] && log_heading "Fetching Webpage Content"

# Change to the chromium directory to ensure proper module resolution
cd "${SCRIPT_DIR}/lib/chromium" || {
  log_error "Failed to change to chromium directory"
  exit 1
}

function attempt_fetch() {
  local mode="$1"
  local attempt_msg="$2"

  [[ ${DEBUG-} ]] && log_message "${attempt_msg}"

  # Build Node.js command arguments array
  declare -a node_cmd_args
  node_cmd_args=("fetch-html.js" "${url}")
  node_cmd_args+=("--timeout" "$((timeout * 1000))")  # Convert to milliseconds
  node_cmd_args+=("--debug-port" "${chrome_debug_port}")
  node_cmd_args+=("--mode" "${mode}")

  if [[ -n "${wait_for_selector}" ]]; then
    node_cmd_args+=("--wait-for" "${wait_for_selector}")
  fi

  if [[ "${debug_mode}" == "true" ]]; then
    node_cmd_args+=("--verbose")
  fi

  # Determine if we should close the tab based on mode and close_tab flag
  local should_close_tab="false"
  if [[ "${mode}" == "headless" ]]; then
    # Always close tabs in headless mode
    should_close_tab="true"
  elif [[ "${mode}" == "visible" || "${mode}" == "connect" ]] && [[ "${close_tab}" == "true" ]]; then
    # For visible/connect modes, only close if explicitly requested
    should_close_tab="true"
  fi

  if [[ "${should_close_tab}" == "true" ]]; then
    node_cmd_args+=("--close-tab")
  fi

  # Execute Node.js script and capture both output and exit code
  local html_content
  local exit_code

  if [[ "${debug_mode}" == "true" ]]; then
    html_content=$(node "${node_cmd_args[@]}")
    exit_code=$?
  else
    html_content=$(node "${node_cmd_args[@]}" 2>/dev/null)
    exit_code=$?
  fi

  # Return the results
  echo "${html_content}"
  return ${exit_code}
}

# First attempt with the determined mode
html_content=$(attempt_fetch "${operation_mode}" "Attempting fetch in ${operation_mode} mode...")
fetch_exit_code=$?

# Handle the result
if [[ ${fetch_exit_code} -eq 0 ]]; then
  [[ ${DEBUG-} ]] && log_success "HTML content retrieved successfully"
elif [[ ${fetch_exit_code} -eq 2 ]]; then
  # Authentication required - try visible mode if not already tried
  if [[ "${operation_mode}" != "visible" ]]; then
    log_warning "Authentication required - launching visible Chromium for user authentication"
    log_message "Please authenticate in the browser window that opens"

    html_content=$(attempt_fetch "visible" "Opening visible browser for authentication...")
    fetch_exit_code=$?

    if [[ ${fetch_exit_code} -eq 0 ]]; then
      [[ ${DEBUG-} ]] && log_success "HTML content retrieved successfully after authentication"
    elif [[ ${fetch_exit_code} -eq 3 ]]; then
      log_success "Browser opened for authentication"
      log_message "Please sign in to the page in the browser window"
      log_message "Once authenticated, run the command again to fetch the content"
      log_message "The browser window has been left open for your convenience"
      exit 0
    else
      log_error "Failed to open browser for authentication"
      exit 1
    fi
  else
    log_error "Authentication required but already in visible mode"
    log_message "Please sign in to the page in the browser window"
    log_message "Once authenticated, run the command again to fetch the content"
    exit 3
  fi
else
  # Other error
  if [[ "${debug_mode}" != "true" ]]; then
    # Get error details by re-running the command
    declare -a node_debug_args
    node_debug_args=("fetch-html.js" "${url}")
    node_debug_args+=("--timeout" "$((timeout * 1000))")
    node_debug_args+=("--debug-port" "${chrome_debug_port}")
    node_debug_args+=("--mode" "${operation_mode}")

    if [[ -n "${wait_for_selector}" ]]; then
      node_debug_args+=("--wait-for" "${wait_for_selector}")
    fi

    # Apply the same close-tab logic for error debugging
    local should_close_tab_debug="false"
    if [[ "${operation_mode}" == "headless" ]]; then
      should_close_tab_debug="true"
    elif [[ "${operation_mode}" == "visible" || "${operation_mode}" == "connect" ]] && [[ "${close_tab}" == "true" ]]; then
      should_close_tab_debug="true"
    fi

    if [[ "${should_close_tab_debug}" == "true" ]]; then
      node_debug_args+=("--close-tab")
    fi

    error_output=$(node "${node_debug_args[@]}" 2>&1 >/dev/null || true)
    if [[ -n "${error_output}" ]]; then
      log_error "Error: ${error_output}"
    fi
  fi
  log_error "Failed to fetch HTML content"
  exit 1
fi

# Output Results
# -----------------------------------------------------------------------------
[[ ${DEBUG-} ]] && log_heading "Output"

# Convert HTML to Markdown unless --html flag is set
if [[ "${html_output}" == "true" ]]; then
  final_content="${html_content}"
  content_type="HTML"
else
  [[ ${DEBUG-} ]] && log_message "Converting HTML to Markdown..."
  if final_content=$(echo "${html_content}" | html2markdown); then
    content_type="Markdown"
    [[ ${DEBUG-} ]] && log_success "HTML converted to Markdown successfully"
  else
    log_warning "Failed to convert HTML to Markdown, falling back to raw HTML"
    final_content="${html_content}"
    content_type="HTML (fallback)"
  fi
fi

# Output to file or stdout
if [[ -n "${output_file}" ]]; then
  echo "${final_content}" > "${output_file}"
  [[ ${DEBUG-} ]] && log_success "${content_type} saved to: '${output_file}'"
  [[ ${DEBUG-} ]] && log_message "Content size: $(echo "${final_content}" | wc -c | tr -d ' ') characters"
else
  echo "${final_content}"
fi

if [[ ${DEBUG-} ]]; then
  log_done "Webpage content fetched and converted successfully"
fi