#!/usr/bin/env bash
# Start AI project development

# Environment setup
# -----------------------------------------------------------------------------
set -o pipefail
[[ ${DEBUG-} ]] && set -o xtrace
SCRIPT_DIR="$(cd "${BASH_SOURCE[0]%/*}" || exit 1; pwd)"
[[ ":${PATH}:" != *:"${SCRIPT_DIR}":* ]] && export PATH="${SCRIPT_DIR}:${PATH}"
source "${SCRIPT_DIR}/bash_modules/terminal.sh"
source "${SCRIPT_DIR}/bash_modules/settings.sh"
source "${SCRIPT_DIR}/bash_modules/utils.sh"
source "${SCRIPT_DIR}/bash_modules/ai.sh"
[[ -z ${BASH_MODULES_DIR-} ]] && echo "ERROR: terminal.sh module missing" && exit 1

function print_usage() {
  cat <<EOF
Usage: $(basename "$0") [--ai <service_class>] [prompt]

Start AI project development

Dependencies:
  claude, gemini, aichat   AI CLI tools

Optional arguments:
  --ai <service_class>  Use specific AI service class (alpha, beta, gamma)
  prompt               Custom prompt to use instead of default file-based prompts
  -h, --help           Show this help message and exit

EOF
}

function format_ai_command_display() {
  local ai_command="$1"

  # Check if command contains single quotes (indicating a long prompt)
  if [[ "${ai_command}" == *\'* ]]; then
    local command_start="${ai_command%%\'*}"
    local command_end="${ai_command##*\'}"
    echo "${command_start}'...'${command_end}"
  else
    echo "${ai_command}"
  fi
}

# Parse arguments
declare ai_service_class=""
declare custom_prompt=""
while [[ $# -gt 0 ]]; do
  case "${1}" in
    -h|--help)
      print_usage
      exit 0
      ;;
    --ai)
      if [[ -z "${2}" ]]; then
        log_error "ERROR: --ai requires a service class argument (alpha, beta, gamma)"
        exit 1
      fi
      ai_service_class="${2}"
      shift 2
      ;;
    -*)
      log_error "ERROR: Unknown option '${1}'"
      print_usage
      exit 1
      ;;
    *)
      if [[ -n "${custom_prompt}" ]]; then
        log_error "ERROR: Only one prompt argument allowed"
        print_usage
        exit 1
      fi
      custom_prompt="${1}"
      shift
      ;;
  esac
done

function ctrlc_trap() {
  log_newline
  log_warning "Script interrupted. Exiting."
  exit 130
}
trap ctrlc_trap SIGINT

# Title and Dependency Checks
# -----------------------------------------------------------------------------
log_title "Starting AI Agent"

# Determine AI service class - default to alpha (claude) for interactive work
declare service_class
if [[ -n "${ai_service_class}" ]]; then
  service_class="${ai_service_class}"
else
  service_class="alpha"  # Default to claude for interactive sessions
fi

log_message "Using AI service class: '${service_class}'"

# Check for ROLE.md file for system prompt
if [[ ! -f "ROLE.md" ]]; then
  log_warning "WARNING: ROLE.md file not found - AI will use default system prompt"
fi

# Main Logic
# -----------------------------------------------------------------------------

declare and_agents=""
declare prompt=""
if [[ -f "AGENTS.md" ]]; then
  and_agents=" and @AGENTS.md"
  prompt="Read @AGENTS.md to understand this environment, then ask me how you can help."
fi

if [[ -n "${custom_prompt}" ]]; then
  log_message "Using custom prompt"
  prompt="${custom_prompt}"
elif [[ -f "PROJECT.md" ]]; then
  log_message "Found PROJECT.md file"
  prompt="Read @PROJECT.md${and_agents}, then propose a detailed, step-by-step plan to achieve the objective."
fi

# Get AI command using new ai module
declare ai_command
if [[ -f "ROLE.md" && -n "${prompt}" ]]; then
  ai_command=$(ai_get_command "${service_class}" mid ROLE.md "${prompt}")
elif [[ -f "ROLE.md" && -z "${prompt}" ]]; then
  ai_command=$(ai_get_command "${service_class}" mid ROLE.md)
elif [[ -n "${prompt}" ]]; then
  ai_command=$(ai_get_command "${service_class}" mid "" "${prompt}")
else
  ai_command=$(ai_get_command "${service_class}" mid)
fi

log_message "Executing AI command..."
log_message "‚ùØ $(format_ai_command_display "${ai_command}")"
eval "${ai_command}"
