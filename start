#!/usr/bin/env bash
# Start AI project development

# Environment setup
# -----------------------------------------------------------------------------
set -o pipefail
[[ ${DEBUG-} ]] && set -o xtrace
SCRIPT_DIR="$(cd "${BASH_SOURCE[0]%/*}" || exit 1; pwd)"
[[ ":${PATH}:" != *:"${SCRIPT_DIR}":* ]] && export PATH="${SCRIPT_DIR}:${PATH}"
source "${SCRIPT_DIR}/bash_modules/terminal.sh"
source "${SCRIPT_DIR}/bash_modules/config.sh"
source "${SCRIPT_DIR}/bash_modules/utils.sh"
source "${SCRIPT_DIR}/bash_modules/ai.sh"
[[ -z ${BASH_MODULES_DIR-} ]] && echo "ERROR: terminal.sh module missing" && exit 1

function print_usage() {
  cat <<EOF
Usage: $(basename "$0") [--ai <service>] [prompt]

Start AI project development

Dependencies:
  claude, gemini, aichat   AI CLI tools

Optional arguments:
  --ai <service>       Use specific AI service (claude, gemini, aichat)
  prompt               Custom prompt to use instead of default file-based prompts
  -h, --help           Show this help message and exit

EOF
}

function format_ai_command_display() {
  local ai_command="$1"

  # Use a variable for the quote character to avoid Bash parsing issues with backslashes
  local q="'"

  # Check if command contains single quotes (indicating a long prompt)
  if [[ "${ai_command}" == *"${q}"* ]]; then
    local command_start="${ai_command%%${q}*}"
    local command_end="${ai_command##*${q}}"
    echo "${command_start}'...'${command_end}"
  else
    echo "${ai_command}"
  fi
}

# Parse arguments
declare ai_service=""
declare custom_prompt=""
while [[ $# -gt 0 ]]; do
  case "${1}" in
    -h|--help)
      print_usage
      exit 0
      ;;
    --ai)
      if [[ -z "${2}" ]]; then
        log_error "ERROR: --ai requires a service argument (claude, gemini, aichat)"
        exit 1
      fi
      ai_service="${2}"
      shift 2
      ;;
    -*)
      log_error "ERROR: Unknown option '${1}'"
      print_usage
      exit 1
      ;;
    *)
      if [[ -n "${custom_prompt}" ]]; then
        log_error "ERROR: Only one prompt argument allowed"
        print_usage
        exit 1
      fi
      custom_prompt="${1}"
      shift
      ;;
  esac
done

function ctrlc_trap() {
  log_newline
  log_warning "Script interrupted. Exiting."
  exit 130
}
trap ctrlc_trap SIGINT

# Title and Dependency Checks
# -----------------------------------------------------------------------------
log_title "Starting AI Agent"

# Determine AI service - default to gemini for interactive work
declare service
service="$(config_get "DEFAULT_AI_AGENT")"
[[ -z "${service}" ]] && service="gemini"

if [[ -n "${ai_service}" ]]; then
  service="${ai_service}"
fi

declare model_tier
case "${service}" in
  claude)
    model_tier="mid"
    ;;
  gemini|aichat)
    model_tier="pro"
    ;;
  *)
    model_tier="fast"
    ;;
esac

log_message "Using AI service: '${service}'"

# Validation Checks
# -----------------------------------------------------------------------------
case "${service}" in
  claude|gemini|aichat)
    # Valid services
    ;;
  *)
    log_error "ERROR: Invalid service '${service}'. Valid options: claude, gemini, aichat"
    exit 1
    ;;
esac


# Main Logic - Exit Early Pattern
# -----------------------------------------------------------------------------

declare role_file="ROLE.md"
if [[ ! -f "ROLE.md" ]]; then
  role_file=""
fi

# Handle custom prompt override - execute immediately and exit
if [[ -n "${custom_prompt}" ]]; then
  log_message "Using custom prompt"
  ai_command=$(ai_get_command "${service}" "${model_tier}" "${role_file}" "${custom_prompt}")
  log_message "Executing AI command..."
  log_message "❯ $(format_ai_command_display "${ai_command}")"
  eval "${ai_command}"
  exit 0
fi

declare prompt=""
prompt+="$(date "+%Y-%m-%dT%H:%M:%S%:z"): "
declare env_prompt="Read the ${HOME}/ref/ENVIRONMENT.md file for environment context. "
env_prompt+="Read the ${HOME}/ref/INDEX.csv for documentation context."
declare cli_prompt="Read the ${HOME}/ref/cli/INDEX.csv for available CLI tool documentation."
declare agents_prompt="Read the AGENTS.md file for repository context."
declare agents_suffix="Respond with the shortest possible summary of the AGENTS.md content."
declare project_prompt="Read the PROJECT.md document. Respond with the project title, and the shortest possible summary of work required. Number the items for ease of reference."
declare greeting_prompt="Respond with a simple greeting."

# Check if AGENTS.md has Active Project and adjust suffix
if [[ -f "AGENTS.md" && ! -f "PROJECT.md" ]] && rg -q "^Active Project:" "AGENTS.md"; then
  agents_suffix="Read the Active Project document listed in AGENTS.md and respond with the project title and shortest possible summary of work required. Number the items for ease of reference."
fi

# Build pattern based on file existence
declare pattern=""
[[ -f "${HOME}/ref/ENVIRONMENT.md" ]] && pattern+="E"
[[ -f "${HOME}/ref/cli/INDEX.csv" ]] && pattern+="C"
[[ -f "AGENTS.md" ]] && pattern+="A"
[[ -f "PROJECT.md" ]] && pattern+="P"

# Set prompt based on file combination pattern
case "${pattern}" in
  "ECAP") prompt+="${env_prompt} ${cli_prompt} ${agents_prompt} ${project_prompt}" ;;
  "ECA")  prompt+="${env_prompt} ${cli_prompt} ${agents_prompt} ${agents_suffix}" ;;
  "ECP")  prompt+="${env_prompt} ${cli_prompt} ${project_prompt}" ;;
  "EC")   prompt+="${env_prompt} ${cli_prompt} ${greeting_prompt}" ;;
  "EAP")  prompt+="${env_prompt} ${agents_prompt} ${project_prompt}" ;;
  "CAP")  prompt+="${cli_prompt} ${agents_prompt} ${project_prompt}" ;;
  "CA")   prompt+="${cli_prompt} ${agents_prompt} ${agents_suffix}" ;;
  "CP")   prompt+="${cli_prompt} ${project_prompt}" ;;
  "AP")   prompt+="${agents_prompt} ${project_prompt}" ;;
  "EA")   prompt+="${env_prompt} ${agents_prompt} ${agents_suffix}" ;;
  "EP")   prompt+="${env_prompt} ${project_prompt}" ;;
  "E")    prompt+="${env_prompt} ${greeting_prompt}" ;;
  "C")    prompt+="${cli_prompt} ${greeting_prompt}" ;;
  "P")    prompt+="${project_prompt}" ;;
  "A")    prompt+="${agents_prompt} ${agents_suffix}" ;;
  *)      prompt+="${greeting_prompt}" ;;
esac

# Execute AI command with determined role file and prompt
# -----------------------------------------------------------------------------
ai_command=$(ai_get_command "${service}" "${model_tier}" "${role_file}" "${prompt}")
log_message "Executing AI command..."
log_message "❯ $(format_ai_command_display "${ai_command}")"
eval "${ai_command}"
