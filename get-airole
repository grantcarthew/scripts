#!/usr/bin/env bash
# Copies my AI Prompts from local directory into the clipboard

# Environment setup
# -----------------------------------------------------------------------------
set -o pipefail # set -o errexit hides errors, don't use it
[[ ${DEBUG-} ]] && set -o xtrace
SCRIPT_DIR="$(cd "${BASH_SOURCE[0]%/*}" || exit 1; pwd)"
[[ ":${PATH}:" != *:"${SCRIPT_DIR}":* ]] && export PATH="${SCRIPT_DIR}:${PATH}"
source "${SCRIPT_DIR}/bash_modules/terminal.sh"
source "${SCRIPT_DIR}/bash_modules/desktop.sh"
[[ -z ${BASH_MODULES_DIR-} ]] && echo "ERROR: terminal.sh module missing" && exit 1

function print_usage() {
  cat <<EOF
Usage: $(basename "$0") [file_filter] [-i|--include-initial-response] [-h]

Copies Grant Carthew's AI role prompts from local directory into the
clipboard or a specified file.

Repository: https://github.com/grantcarthew/scripts/tree/main

Dependencies:
  rg                  For regex matching
  fzf                 For interactive file selection
  OS Dependent:
    - For copying content to the clipboard
    - Linux: xclip or xsel
    - macOS: pbcopy

Optional arguments:
  file_filter                      The file name or part thereof
  -i, --include-initial-response   Include the initial response template
  -h, --help                       Show this help message and exit
EOF
}

file_filter=""
include_initial_response=false

for arg in "$@"; do
  case "$arg" in
    -i|--include-initial-response)
      include_initial_response=true
      ;;
    -h|--help)
      print_usage
      exit 0
      ;;
    *)
      if [[ -z "$file_filter" ]]; then
        file_filter="$arg"
      else
        log_error "ERROR: Too many arguments"
        print_usage
        exit 1
      fi
      ;;
  esac
done

function ctrlc_trap() {
  log_newline
  log_warning "Script interrupted. Exiting."
  exit 130
}
trap ctrlc_trap SIGINT

# Title and Dependency Checks
# -----------------------------------------------------------------------------
log_title "Grant Carthew's Local AI Prompts"

dependencies=(rg fzf)
for cmd in "${dependencies[@]}"; do
  if ! command -v "${cmd}" >/dev/null; then
    log_error "ERROR: Missing dependency - '${cmd}'"
    exit 1
  fi
done

# Load Local Prompts
# -----------------------------------------------------------------------------
log_heading "Loading Local Prompts"

local_path="${SCRIPT_DIR}/ai/roles"

if [[ ! -d "${local_path}" ]]; then
  log_error "ERROR: Local AI roles directory not found at '${local_path}'"
  exit 1
fi

log_message "Loading from: ${local_path}"

readarray -t files < <(find "${local_path}" -name "*.md" -not -name "README.md" -exec basename {} \; | sort)

if [[ -n "$file_filter" ]]; then
  log_message "Filtering for: ${file_filter}"
  readarray -t files < <(printf '%s\n' "${files[@]}" | rg -i "$file_filter")
fi

# File Selection
# -----------------------------------------------------------------------------
log_heading "File Selection"

case ${#files[@]} in
0)
  log_error "No files match your filter."
  exit 1
  ;;
1)
  selected_file="${files[0]}"
  log_success "File: ${selected_file}"
  ;;
*)
  log_message "Select a file using fzf (use arrow keys, type to filter, Enter to select):"
  selected_file=$(printf '%s\n' "${files[@]}" | fzf --height 40% --layout=reverse --border)

  if [[ -z "${selected_file}" ]]; then
    log_error "No file selected. Operation canceled."
    exit 1
  fi

  log_success "Selected: ${selected_file}"
  ;;
esac

# Load Prompt Content
# -----------------------------------------------------------------------------
log_heading "Loading Prompt"

local_file="${local_path}/${selected_file}"
log_message "Loading from: ${local_file}"

if [[ ! -f "${local_file}" ]]; then
  log_error "ERROR: File not found at '${local_file}'"
  exit 1
fi

raw_content="$(cat "${local_file}")"

if [[ -z "${raw_content}" ]]; then
  log_error "ERROR: Failed to read content from '${local_file}'"
  exit 1
fi

log_message "Prompt title: $(echo "${raw_content}" | rg -m 1 '^#')"

if [[ "$include_initial_response" == true ]]; then
  log_message "Adding initial response template"
  raw_content+="$(
    cat <<EOT


## Initial Response

Respond only once to this message with "I am an expert in {{subject}}, let's get working!"

EOT
  )"
fi

# Output Result
# -----------------------------------------------------------------------------
# If we are outputting to a terminal, copy to clipboard.
if [[ -t 1 ]]; then
  send_to_clipboard "${raw_content}"
  log_success "File contents copied to clipboard!"
else
  echo -n "${raw_content}"
  log_success "File contents written to stdout!"
fi
log_done
